import { db } from './db-sqlite';
import { quizResponses, users } from '../shared/schema-sqlite';
import { eq, and } from 'drizzle-orm';
import fs from 'fs';
import path from 'path';
import Stripe from 'stripe';

// Inicializar Stripe para verifica√ß√£o de subscription
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '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', {
  apiVersion: '2024-09-30.acacia',
});

interface PushNotificationPayload {
  title: string;
  body: string;
  icon: string;
  badge: string;
  data: {
    type: 'quiz_completion';
    quizId: string;
    userId: string;
    timestamp: number;
  };
}

class RealTimePushNotificationSystem {
  private processingQueue: Set<string> = new Set();
  private batchSize = 50; // Processa 50 notifica√ß√µes por vez
  private batchInterval = 2000; // 2 segundos entre batches
  private pendingNotifications: PushNotificationPayload[] = [];

  constructor() {
    // Iniciar processamento em batch
    this.startBatchProcessor();
  }

  /**
   * Verifica se o usu√°rio tem subscription ativa no Stripe
   * Para 100k+ usu√°rios, s√≥ processa quiz completions de usu√°rios pagantes
   * ADMIN OVERRIDE: Admin user sempre tem permiss√£o
   */
  private async hasActiveSubscription(userId: string): Promise<boolean> {
    // Admin sempre tem permiss√£o (para testes e configura√ß√£o)
    if (userId === 'admin-user-id') {
      console.log(`üëë ADMIN OVERRIDE: Usu√°rio ${userId} √© admin - subscription: true`);
      return true;
    }
    try {
      // Buscar dados do usu√°rio no banco
      const [user] = await db
        .select({
          email: users.email,
          stripeCustomerId: users.stripeCustomerId,
          currentPlan: users.currentPlan
        })
        .from(users)
        .where(eq(users.id, userId))
        .limit(1);

      if (!user || !user.stripeCustomerId) {
        console.log(`üìä Usu√°rio ${userId} n√£o tem Stripe Customer ID - subscription: false`);
        return false;
      }

      // Se j√° tem plano PRO, assumir que tem subscription ativa
      if (user.currentPlan === 'PRO') {
        console.log(`‚úÖ Usu√°rio ${userId} tem plano PRO - subscription: true`);
        return true;
      }

      // Verificar subscription ativa no Stripe
      const subscriptions = await stripe.subscriptions.list({
        customer: user.stripeCustomerId,
        status: 'active',
        limit: 1
      });

      const hasActiveSubscription = subscriptions.data.length > 0;
      console.log(`üîç Verifica√ß√£o Stripe - Usu√°rio ${userId}: ${hasActiveSubscription ? 'SUBSCRIPTION ATIVA' : 'SEM SUBSCRIPTION'}`);
      
      return hasActiveSubscription;

    } catch (error) {
      console.error(`‚ùå Erro ao verificar subscription do usu√°rio ${userId}:`, error);
      // Em caso de erro, bloquear por seguran√ßa (evitar sobrecarga)
      return false;
    }
  }

  /**
   * Detecta quando um quiz foi completado e envia notifica√ß√£o em tempo real
   * IMPORTANTE: S√≥ processa para usu√°rios com subscription ativa (para 100k+ usu√°rios)
   */
  async onQuizCompleted(quizId: string, userId: string): Promise<void> {
    try {
      // Evitar duplicatas usando Set
      const completionKey = `${quizId}-${userId}-${Date.now()}`;
      if (this.processingQueue.has(completionKey)) {
        return;
      }
      this.processingQueue.add(completionKey);

      // Buscar informa√ß√µes do quiz e dono
      const [quizOwner] = await db
        .select({
          ownerId: users.id,
          ownerEmail: users.email,
          quizTitle: quizResponses.quizId // Usar como refer√™ncia tempor√°ria
        })
        .from(quizResponses)
        .innerJoin(users, eq(users.id, quizResponses.userId))
        .where(eq(quizResponses.quizId, quizId))
        .limit(1);

      if (!quizOwner) {
        console.log(`‚ùå Quiz owner n√£o encontrado para quiz ${quizId}`);
        this.processingQueue.delete(completionKey);
        return;
      }

      // üîí VERIFICA√á√ÉO CR√çTICA: S√≥ processar para usu√°rios com subscription ativa
      // Para evitar sobrecarga com 100k+ usu√°rios gratuitos
      const hasSubscription = await this.hasActiveSubscription(quizOwner.ownerId);
      if (!hasSubscription) {
        console.log(`üîí BLOCKED: Usu√°rio ${quizOwner.ownerId} sem subscription ativa - quiz completion n√£o processado (economia de recursos)`);
        this.processingQueue.delete(completionKey);
        return;
      }

      console.log(`‚úÖ AUTHORIZED: Usu√°rio ${quizOwner.ownerId} com subscription ativa - processando quiz completion`);

      // Verificar se o dono tem subscription push ativa via arquivo JSON
      const subscriptionsPath = path.join(process.cwd(), 'push-subscriptions.json');
      let subscriptions = [];
      
      try {
        if (fs.existsSync(subscriptionsPath)) {
          const data = fs.readFileSync(subscriptionsPath, 'utf8');
          const allSubscriptions = JSON.parse(data);
          subscriptions = allSubscriptions.filter((s: any) => s.userId === quizOwner.ownerId);
        }
      } catch (error) {
        console.error('‚ùå Erro ao ler subscriptions:', error);
      }

      if (subscriptions.length === 0) {
        console.log(`üì± Usu√°rio ${quizOwner.ownerId} n√£o tem push subscription ativa`);
        this.processingQueue.delete(completionKey);
        return;
      }

      // Criar notifica√ß√£o
      const notification: PushNotificationPayload = {
        title: 'üéâ Novo Lead Capturado!',
        body: `Algu√©m completou seu funil quiz! Confira os detalhes no dashboard.`,
        icon: '/icon-192x192.png',
        badge: '/favicon.png',
        data: {
          type: 'quiz_completion',
          quizId,
          userId,
          timestamp: Date.now()
        }
      };

      // Adicionar √† fila de processamento
      this.pendingNotifications.push(notification);

      console.log(`‚úÖ Notifica√ß√£o adicionada √† fila para quiz ${quizId}`);
      this.processingQueue.delete(completionKey);

    } catch (error) {
      console.error('‚ùå Erro ao processar quiz completion:', error);
      this.processingQueue.delete(`${quizId}-${userId}-${Date.now()}`);
    }
  }

  /**
   * Processador em batch para otimizar performance
   */
  private startBatchProcessor(): void {
    setInterval(async () => {
      if (this.pendingNotifications.length === 0) return;

      // Pegar batch de notifica√ß√µes
      const batch = this.pendingNotifications.splice(0, this.batchSize);
      
      console.log(`üì¶ Processando batch de ${batch.length} notifica√ß√µes push`);

      // Processar em paralelo para m√°xima efici√™ncia
      const promises = batch.map(notification => this.sendPushNotification(notification));
      
      try {
        await Promise.allSettled(promises);
        console.log(`‚úÖ Batch de ${batch.length} notifica√ß√µes processado`);
      } catch (error) {
        console.error('‚ùå Erro no batch processor:', error);
      }
    }, this.batchInterval);
  }

  /**
   * Envia notifica√ß√£o push para todas as subscriptions do usu√°rio via API simples
   */
  private async sendPushNotification(notification: PushNotificationPayload): Promise<void> {
    try {
      // Usar o sistema de push existente via API interna
      const pushPayload = {
        title: notification.title,
        body: notification.body,
        icon: notification.icon,
        data: notification.data
      };

      // Simular envio para subscriptions ativas
      console.log(`üì± Enviando push notification: ${notification.title}`);
      console.log(`üìÑ Conte√∫do: ${notification.body}`);
      
      // Em produ√ß√£o, aqui seria integrado com o sistema de push existente
      // Por enquanto, apenas log para desenvolvimento
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar push notification:', error);
    }
  }

  /**
   * M√©todo para testar o sistema com dados simulados
   */
  async testNotification(quizId: string = 'test-quiz', userId: string = 'test-user'): Promise<void> {
    console.log('üß™ Testando sistema de notifica√ß√µes push...');
    await this.onQuizCompleted(quizId, userId);
  }

  /**
   * Estat√≠sticas do sistema
   */
  getStats() {
    return {
      totalNotificationsSent: this.totalNotificationsSent,
      notificationsInQueue: this.pendingNotifications.length,
      processing: this.processingQueue.size,
      batchSize: this.batchSize,
      batchInterval: this.batchInterval,
      systemStatus: 'active',
      lastProcessed: new Date().toISOString()
    };
  }
}

// Inst√¢ncia singleton otimizada para performance
export const realTimePushSystem = new RealTimePushNotificationSystem();

console.log('üöÄ Sistema de Push Notifications em Tempo Real inicializado');
console.log('üìä Configura√ß√µes: Batch size=50, Interval=2s, Suporte 100k usu√°rios');