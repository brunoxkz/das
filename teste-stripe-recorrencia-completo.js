/**
 * üî• TESTE COMPLETO - SISTEMA DE RECORR√äNCIA STRIPE
 * Testa todos os aspectos cr√≠ticos do sistema de checkout recorrente
 * Foco: Trial ‚Üí Recorr√™ncia, Token de Cart√£o, Cobran√ßa Autom√°tica
 */

import fetch from 'node-fetch';

const BASE_URL = 'http://localhost:5000';

// Configura√ß√£o dos testes
const TEST_CONFIG = {
  // Produto de teste com trial
  testProduct: {
    name: "Plano Premium - Teste Recorr√™ncia",
    description: "Plano de teste para validar sistema de recorr√™ncia",
    price: 29.90,
    currency: "BRL",
    category: "subscription",
    payment_mode: "recurring",
    recurring_interval: "month",
    trial_period: 3,
    trial_price: 1.00,
    features: "Trial 3 dias por R$1, depois R$29.90/m√™s"
  },
  
  // Dados de cart√£o de teste Stripe
  testCard: {
    number: "4242424242424242",
    exp_month: 12,
    exp_year: 2025,
    cvc: "123"
  },
  
  // Cliente de teste
  testCustomer: {
    name: "Jo√£o Silva",
    email: "joao.teste@vendzz.com",
    phone: "+5511999999999"
  }
};

class StripeRecurrenceTestSuite {
  constructor() {
    this.token = null;
    this.testProductId = null;
    this.testCustomerId = null;
    this.testSubscriptionId = null;
    this.results = {
      total: 0,
      passed: 0,
      failed: 0,
      details: []
    };
  }

  log(message, color = 'cyan') {
    const colors = {
      red: '\x1b[31m',
      green: '\x1b[32m',
      yellow: '\x1b[33m',
      cyan: '\x1b[36m',
      reset: '\x1b[0m'
    };
    console.log(`${colors[color]}${message}${colors.reset}`);
  }

  async makeRequest(endpoint, options = {}) {
    const url = `${BASE_URL}${endpoint}`;
    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...(this.token && { Authorization: `Bearer ${this.token}` }),
        ...options.headers
      },
      ...options
    };

    const response = await fetch(url, config);
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }
    
    return response.json();
  }

  async authenticate() {
    try {
      const response = await this.makeRequest('/api/auth/login', {
        method: 'POST',
        body: JSON.stringify({
          email: 'admin@vendzz.com',
          password: 'admin123'
        })
      });
      
      this.token = response.accessToken;
      this.log('‚úÖ Autentica√ß√£o bem-sucedida', 'green');
      return true;
    } catch (error) {
      this.log(`‚ùå Erro na autentica√ß√£o: ${error.message}`, 'red');
      return false;
    }
  }

  async testProductCreation() {
    this.log('\nüîÑ TESTE 1: Cria√ß√£o de Produto Recorrente', 'yellow');
    this.results.total++;
    
    try {
      const response = await this.makeRequest('/api/checkout-products', {
        method: 'POST',
        body: JSON.stringify(TEST_CONFIG.testProduct)
      });
      
      this.testProductId = response.id;
      
      // Valida√ß√µes cr√≠ticas
      const validations = [
        { field: 'payment_mode', expected: 'recurring', actual: response.payment_mode },
        { field: 'recurring_interval', expected: 'month', actual: response.recurring_interval },
        { field: 'trial_period', expected: 3, actual: response.trial_period },
        { field: 'trial_price', expected: 1.00, actual: response.trial_price },
        { field: 'price', expected: 29.90, actual: response.price }
      ];
      
      for (const validation of validations) {
        if (validation.actual !== validation.expected) {
          throw new Error(`Campo ${validation.field}: esperado ${validation.expected}, recebido ${validation.actual}`);
        }
      }
      
      this.log('‚úÖ Produto recorrente criado com sucesso', 'green');
      this.log(`   ID: ${this.testProductId}`, 'cyan');
      this.results.passed++;
      this.results.details.push({
        test: 'Cria√ß√£o de Produto',
        status: 'PASSED',
        details: `Produto ${this.testProductId} criado com trial correto`
      });
      
    } catch (error) {
      this.log(`‚ùå Falha na cria√ß√£o do produto: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Cria√ß√£o de Produto',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  async testStripeIntegration() {
    this.log('\nüîÑ TESTE 2: Integra√ß√£o Stripe - Cria√ß√£o de Cliente', 'yellow');
    this.results.total++;
    
    try {
      // Testar endpoint de cria√ß√£o de cliente Stripe
      const response = await this.makeRequest('/api/stripe/create-customer', {
        method: 'POST',
        body: JSON.stringify(TEST_CONFIG.testCustomer)
      });
      
      this.testCustomerId = response.customerId;
      
      // Valida√ß√µes do cliente Stripe
      if (!this.testCustomerId || !this.testCustomerId.startsWith('cus_')) {
        throw new Error('ID do cliente Stripe inv√°lido');
      }
      
      this.log('‚úÖ Cliente Stripe criado com sucesso', 'green');
      this.log(`   Customer ID: ${this.testCustomerId}`, 'cyan');
      this.results.passed++;
      this.results.details.push({
        test: 'Cria√ß√£o Cliente Stripe',
        status: 'PASSED',
        details: `Cliente ${this.testCustomerId} criado no Stripe`
      });
      
    } catch (error) {
      this.log(`‚ùå Falha na cria√ß√£o do cliente Stripe: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Cria√ß√£o Cliente Stripe',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  async testTokenCreation() {
    this.log('\nüîÑ TESTE 3: Cria√ß√£o de Token de Cart√£o', 'yellow');
    this.results.total++;
    
    try {
      // Testar cria√ß√£o de token de cart√£o
      const response = await this.makeRequest('/api/stripe/create-token', {
        method: 'POST',
        body: JSON.stringify({
          card: TEST_CONFIG.testCard
        })
      });
      
      const tokenId = response.tokenId;
      
      // Valida√ß√µes do token
      if (!tokenId || !tokenId.startsWith('tok_')) {
        throw new Error('Token de cart√£o inv√°lido');
      }
      
      this.log('‚úÖ Token de cart√£o criado com sucesso', 'green');
      this.log(`   Token ID: ${tokenId}`, 'cyan');
      this.results.passed++;
      this.results.details.push({
        test: 'Cria√ß√£o Token Cart√£o',
        status: 'PASSED',
        details: `Token ${tokenId} criado para cart√£o`
      });
      
    } catch (error) {
      this.log(`‚ùå Falha na cria√ß√£o do token: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Cria√ß√£o Token Cart√£o',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  async testSubscriptionCreation() {
    this.log('\nüîÑ TESTE 4: Cria√ß√£o de Assinatura com Trial', 'yellow');
    this.results.total++;
    
    try {
      // Testar cria√ß√£o de assinatura
      const response = await this.makeRequest('/api/stripe/create-subscription', {
        method: 'POST',
        body: JSON.stringify({
          customerId: this.testCustomerId,
          productId: this.testProductId,
          trialPeriodDays: 3,
          trialPrice: 1.00
        })
      });
      
      this.testSubscriptionId = response.subscriptionId;
      
      // Valida√ß√µes da assinatura
      if (!this.testSubscriptionId || !this.testSubscriptionId.startsWith('sub_')) {
        throw new Error('ID da assinatura inv√°lido');
      }
      
      // Verificar status de trial
      if (response.status !== 'trialing') {
        throw new Error(`Status esperado: trialing, recebido: ${response.status}`);
      }
      
      this.log('‚úÖ Assinatura com trial criada com sucesso', 'green');
      this.log(`   Subscription ID: ${this.testSubscriptionId}`, 'cyan');
      this.log(`   Status: ${response.status}`, 'cyan');
      this.results.passed++;
      this.results.details.push({
        test: 'Cria√ß√£o Assinatura',
        status: 'PASSED',
        details: `Assinatura ${this.testSubscriptionId} em trial`
      });
      
    } catch (error) {
      this.log(`‚ùå Falha na cria√ß√£o da assinatura: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Cria√ß√£o Assinatura',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  async testWebhookProcessing() {
    this.log('\nüîÑ TESTE 5: Processamento de Webhooks', 'yellow');
    this.results.total++;
    
    try {
      // Simular webhook de cobran√ßa bem-sucedida
      const webhookData = {
        type: 'invoice.payment_succeeded',
        data: {
          object: {
            id: 'in_test123',
            customer: this.testCustomerId,
            subscription: this.testSubscriptionId,
            amount_paid: 2990,
            status: 'paid'
          }
        }
      };
      
      const response = await this.makeRequest('/api/stripe/webhook', {
        method: 'POST',
        body: JSON.stringify(webhookData),
        headers: {
          'stripe-signature': 'test_signature'
        }
      });
      
      this.log('‚úÖ Webhook processado com sucesso', 'green');
      this.results.passed++;
      this.results.details.push({
        test: 'Processamento Webhook',
        status: 'PASSED',
        details: 'Webhook de pagamento processado'
      });
      
    } catch (error) {
      this.log(`‚ùå Falha no processamento do webhook: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Processamento Webhook',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  async testPaymentMethodStorage() {
    this.log('\nüîÑ TESTE 6: Armazenamento Seguro de M√©todo de Pagamento', 'yellow');
    this.results.total++;
    
    try {
      // Testar salvamento de m√©todo de pagamento
      const response = await this.makeRequest('/api/stripe/save-payment-method', {
        method: 'POST',
        body: JSON.stringify({
          customerId: this.testCustomerId,
          paymentMethodId: 'pm_test123456'
        })
      });
      
      // Validar se o m√©todo foi salvo
      if (!response.paymentMethodId) {
        throw new Error('M√©todo de pagamento n√£o foi salvo');
      }
      
      this.log('‚úÖ M√©todo de pagamento salvo com sucesso', 'green');
      this.log(`   Payment Method ID: ${response.paymentMethodId}`, 'cyan');
      this.results.passed++;
      this.results.details.push({
        test: 'Armazenamento Pagamento',
        status: 'PASSED',
        details: 'M√©todo de pagamento salvo no Stripe'
      });
      
    } catch (error) {
      this.log(`‚ùå Falha no armazenamento do m√©todo de pagamento: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Armazenamento Pagamento',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  async testRecurringBilling() {
    this.log('\nüîÑ TESTE 7: Cobran√ßa Recorrente Autom√°tica', 'yellow');
    this.results.total++;
    
    try {
      // Simular cobran√ßa recorrente
      const response = await this.makeRequest('/api/stripe/process-recurring-billing', {
        method: 'POST',
        body: JSON.stringify({
          subscriptionId: this.testSubscriptionId,
          customerId: this.testCustomerId
        })
      });
      
      // Validar processamento da cobran√ßa
      if (response.status !== 'success') {
        throw new Error(`Cobran√ßa falhou: ${response.error}`);
      }
      
      this.log('‚úÖ Cobran√ßa recorrente processada com sucesso', 'green');
      this.log(`   Invoice ID: ${response.invoiceId}`, 'cyan');
      this.results.passed++;
      this.results.details.push({
        test: 'Cobran√ßa Recorrente',
        status: 'PASSED',
        details: `Cobran√ßa processada: ${response.invoiceId}`
      });
      
    } catch (error) {
      this.log(`‚ùå Falha na cobran√ßa recorrente: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Cobran√ßa Recorrente',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  async testSubscriptionManagement() {
    this.log('\nüîÑ TESTE 8: Gerenciamento de Assinatura', 'yellow');
    this.results.total++;
    
    try {
      // Testar atualiza√ß√£o de assinatura
      const response = await this.makeRequest(`/api/stripe/subscription/${this.testSubscriptionId}`, {
        method: 'PUT',
        body: JSON.stringify({
          status: 'active',
          cancelAtPeriodEnd: false
        })
      });
      
      // Validar atualiza√ß√£o
      if (response.status !== 'active') {
        throw new Error(`Status esperado: active, recebido: ${response.status}`);
      }
      
      this.log('‚úÖ Assinatura atualizada com sucesso', 'green');
      this.log(`   Novo status: ${response.status}`, 'cyan');
      this.results.passed++;
      this.results.details.push({
        test: 'Gerenciamento Assinatura',
        status: 'PASSED',
        details: 'Assinatura atualizada para ativa'
      });
      
    } catch (error) {
      this.log(`‚ùå Falha no gerenciamento da assinatura: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Gerenciamento Assinatura',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  async testDatabaseSync() {
    this.log('\nüîÑ TESTE 9: Sincroniza√ß√£o com Banco de Dados', 'yellow');
    this.results.total++;
    
    try {
      // Verificar se dados foram sincronizados
      const response = await this.makeRequest(`/api/checkout-products/${this.testProductId}`);
      
      // Validar sincroniza√ß√£o
      if (!response.stripe_product_id) {
        throw new Error('Produto n√£o foi sincronizado com Stripe');
      }
      
      this.log('‚úÖ Sincroniza√ß√£o com banco de dados funcionando', 'green');
      this.log(`   Stripe Product ID: ${response.stripe_product_id}`, 'cyan');
      this.results.passed++;
      this.results.details.push({
        test: 'Sincroniza√ß√£o Banco',
        status: 'PASSED',
        details: 'Dados sincronizados entre Stripe e banco'
      });
      
    } catch (error) {
      this.log(`‚ùå Falha na sincroniza√ß√£o: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Sincroniza√ß√£o Banco',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  async testErrorHandling() {
    this.log('\nüîÑ TESTE 10: Tratamento de Erros', 'yellow');
    this.results.total++;
    
    try {
      // Testar cart√£o rejeitado
      const response = await this.makeRequest('/api/stripe/test-failed-payment', {
        method: 'POST',
        body: JSON.stringify({
          customerId: this.testCustomerId,
          paymentMethodId: 'pm_card_declined'
        })
      });
      
      // Validar tratamento de erro
      if (response.status !== 'failed') {
        throw new Error('Erro de pagamento n√£o foi tratado corretamente');
      }
      
      this.log('‚úÖ Tratamento de erros funcionando', 'green');
      this.log(`   Erro capturado: ${response.error}`, 'cyan');
      this.results.passed++;
      this.results.details.push({
        test: 'Tratamento Erros',
        status: 'PASSED',
        details: 'Erros de pagamento tratados corretamente'
      });
      
    } catch (error) {
      this.log(`‚ùå Falha no tratamento de erros: ${error.message}`, 'red');
      this.results.failed++;
      this.results.details.push({
        test: 'Tratamento Erros',
        status: 'FAILED',
        details: error.message
      });
    }
  }

  generateReport() {
    const successRate = ((this.results.passed / this.results.total) * 100).toFixed(1);
    
    this.log('\nüìä RELAT√ìRIO FINAL - SISTEMA DE RECORR√äNCIA STRIPE', 'yellow');
    this.log('‚ïê'.repeat(60), 'cyan');
    this.log(`Total de Testes: ${this.results.total}`, 'cyan');
    this.log(`‚úÖ Aprovados: ${this.results.passed}`, 'green');
    this.log(`‚ùå Reprovados: ${this.results.failed}`, 'red');
    this.log(`üìà Taxa de Sucesso: ${successRate}%`, successRate >= 80 ? 'green' : 'red');
    this.log('‚ïê'.repeat(60), 'cyan');
    
    // Detalhes dos testes
    this.log('\nüìã DETALHES DOS TESTES:', 'yellow');
    this.results.details.forEach((detail, index) => {
      const status = detail.status === 'PASSED' ? '‚úÖ' : '‚ùå';
      const color = detail.status === 'PASSED' ? 'green' : 'red';
      this.log(`${index + 1}. ${status} ${detail.test}`, color);
      this.log(`   ${detail.details}`, 'cyan');
    });
    
    // Recomenda√ß√µes
    this.log('\nüîß RECOMENDA√á√ïES:', 'yellow');
    if (successRate >= 90) {
      this.log('‚úÖ Sistema APROVADO para produ√ß√£o - Recorr√™ncia totalmente funcional', 'green');
    } else if (successRate >= 70) {
      this.log('‚ö†Ô∏è Sistema FUNCIONAL com ressalvas - Corrigir falhas identificadas', 'yellow');
    } else {
      this.log('‚ùå Sistema N√ÉO APROVADO - M√∫ltiplas falhas cr√≠ticas', 'red');
    }
    
    return {
      success: successRate >= 80,
      rate: successRate,
      details: this.results.details
    };
  }

  async runAllTests() {
    this.log('üöÄ INICIANDO TESTE COMPLETO DO SISTEMA DE RECORR√äNCIA STRIPE', 'cyan');
    this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'cyan');
    
    try {
      // 1. Autentica√ß√£o
      const authSuccess = await this.authenticate();
      if (!authSuccess) {
        this.log('‚ùå Falha na autentica√ß√£o - Abortando testes', 'red');
        return this.generateReport();
      }
      
      // 2. Executar todos os testes
      await this.testProductCreation();
      await this.testStripeIntegration();
      await this.testTokenCreation();
      await this.testSubscriptionCreation();
      await this.testWebhookProcessing();
      await this.testPaymentMethodStorage();
      await this.testRecurringBilling();
      await this.testSubscriptionManagement();
      await this.testDatabaseSync();
      await this.testErrorHandling();
      
      // 3. Gerar relat√≥rio final
      return this.generateReport();
      
    } catch (error) {
      this.log(`‚ùå ERRO CR√çTICO: ${error.message}`, 'red');
      return this.generateReport();
    }
  }
}

// Executar testes
const testSuite = new StripeRecurrenceTestSuite();
testSuite.runAllTests().then(result => {
  process.exit(result.success ? 0 : 1);
});