#!/usr/bin/env node

/**
 * üîç TESTE COMPLETO DO SISTEMA DE CR√âDITOS
 * Verifica: Email Marketing, SMS, Stripe, Planos de Quiz, Renova√ß√£o, Expira√ß√£o
 */

import fetch from 'node-fetch';

const BASE_URL = 'http://localhost:5000';

// Cores para logs
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

function log(message, color = 'white') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// Fun√ß√£o para requisi√ß√µes HTTP
async function makeRequest(endpoint, options = {}) {
  const url = `${BASE_URL}${endpoint}`;
  const defaultOptions = {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  };

  const response = await fetch(url, { ...defaultOptions, ...options });
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`HTTP ${response.status}: ${error}`);
  }
  
  return response.json();
}

// Autentica√ß√£o
async function authenticate() {
  try {
    const response = await makeRequest('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify({
        email: 'admin@admin.com',
        password: 'admin123'
      })
    });
    
    log('‚úÖ Autenticado com sucesso', 'green');
    // Verificar se o token est√° no accessToken ou token
    let token = response.accessToken || response.token;
    
    // Se n√£o tiver token, tentar refresh
    if (!token && response.refreshToken) {
      try {
        const refreshResponse = await makeRequest('/api/auth/refresh', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${response.refreshToken}`
          }
        });
        token = refreshResponse.accessToken || refreshResponse.token;
      } catch (refreshError) {
        log(`‚ö†Ô∏è Erro ao fazer refresh: ${refreshError.message}`, 'yellow');
      }
    }
    
    return token;
  } catch (error) {
    log(`‚ùå Erro na autentica√ß√£o: ${error.message}`, 'red');
    throw error;
  }
}

// Teste 1: Sistema de Cr√©ditos Email Marketing
async function testarCreditosEmailMarketing(token) {
  log('\nüìß TESTE 1: Sistema de Cr√©ditos Email Marketing', 'cyan');
  
  try {
    // Buscar cr√©ditos de email
    const emailCredits = await makeRequest('/api/email-credits', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üìä Cr√©ditos de Email: ${JSON.stringify(emailCredits, null, 2)}`, 'blue');
    
    // Verificar se possui endpoint espec√≠fico para email-credits
    const userCredits = await makeRequest('/api/user/credits', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üìä Cr√©ditos do Usu√°rio: ${JSON.stringify(userCredits, null, 2)}`, 'blue');
    
    // Verificar se cr√©ditos de email est√£o no breakdown
    if (userCredits.breakdown && userCredits.breakdown.email !== undefined) {
      log('‚úÖ Cr√©ditos de Email est√£o sincronizados no sistema unificado', 'green');
      return {
        success: true,
        emailCredits: userCredits.breakdown.email,
        status: userCredits.status.email
      };
    } else {
      log('‚ùå Cr√©ditos de Email n√£o encontrados no sistema unificado', 'red');
      return { success: false, error: 'Email credits not found' };
    }
    
  } catch (error) {
    log(`‚ùå Erro no teste de cr√©ditos de email: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

// Teste 2: Sistema de Cr√©ditos SMS
async function testarCreditosSMS(token) {
  log('\nüì± TESTE 2: Sistema de Cr√©ditos SMS', 'cyan');
  
  try {
    // Buscar cr√©ditos de SMS
    const smsCredits = await makeRequest('/api/sms-credits', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üìä Cr√©ditos de SMS: ${JSON.stringify(smsCredits, null, 2)}`, 'blue');
    
    // Verificar se √© v√°lido e tem restante
    if (smsCredits.valid && smsCredits.remaining !== undefined) {
      log('‚úÖ Cr√©ditos de SMS est√£o funcionando', 'green');
      return {
        success: true,
        smsCredits: smsCredits.remaining,
        plan: smsCredits.plan,
        valid: smsCredits.valid
      };
    } else {
      log('‚ùå Problema com cr√©ditos de SMS', 'red');
      return { success: false, error: smsCredits.error || 'SMS credits invalid' };
    }
    
  } catch (error) {
    log(`‚ùå Erro no teste de cr√©ditos de SMS: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

// Teste 3: Integra√ß√£o com Stripe
async function testarIntegra√ß√£oStripe(token) {
  log('\nüí≥ TESTE 3: Integra√ß√£o com Stripe', 'cyan');
  
  try {
    // Testar compra de cr√©ditos
    const purchaseResult = await makeRequest('/api/credits/purchase', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${token}` },
      body: JSON.stringify({
        type: 'email',
        packageId: 'email_1000'
      })
    });
    
    log(`üí∞ Resultado da compra: ${JSON.stringify(purchaseResult, null, 2)}`, 'blue');
    
    if (purchaseResult.success) {
      log('‚úÖ Sistema de compra de cr√©ditos est√° funcionando', 'green');
      return { success: true, purchaseResult };
    } else {
      log('‚ùå Erro na compra de cr√©ditos', 'red');
      return { success: false, error: purchaseResult.error };
    }
    
  } catch (error) {
    log(`‚ùå Erro na integra√ß√£o Stripe: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

// Teste 4: Sistema de Planos de Quiz
async function testarPlanosQuiz(token) {
  log('\nüéØ TESTE 4: Sistema de Planos de Quiz', 'cyan');
  
  try {
    // Buscar planos de assinatura
    const subscriptionPlans = await makeRequest('/api/subscription-plans', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üìã Planos de assinatura: ${JSON.stringify(subscriptionPlans, null, 2)}`, 'blue');
    
    // Verificar limites de plano
    const planLimits = await makeRequest('/api/plan-limits', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üìä Limites do plano: ${JSON.stringify(planLimits, null, 2)}`, 'blue');
    
    // Verificar acesso a funcionalidades
    const featureAccess = await makeRequest('/api/feature-access/quiz-creation', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üîì Acesso a funcionalidades: ${JSON.stringify(featureAccess, null, 2)}`, 'blue');
    
    if (planLimits && featureAccess) {
      log('‚úÖ Sistema de planos de quiz est√° funcionando', 'green');
      return {
        success: true,
        plans: subscriptionPlans,
        limits: planLimits,
        access: featureAccess
      };
    } else {
      log('‚ùå Problema com sistema de planos', 'red');
      return { success: false, error: 'Plan system not working' };
    }
    
  } catch (error) {
    log(`‚ùå Erro no teste de planos de quiz: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

// Teste 5: Expira√ß√£o de Plano e Renova√ß√£o
async function testarExpiracaoRenovacao(token) {
  log('\n‚è∞ TESTE 5: Expira√ß√£o de Plano e Renova√ß√£o', 'cyan');
  
  try {
    // Verificar status do usu√°rio
    const userStatus = await makeRequest('/api/user/status', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üë§ Status do usu√°rio: ${JSON.stringify(userStatus, null, 2)}`, 'blue');
    
    // Simular cria√ß√£o de quiz para testar bloqueio
    const quizTest = await makeRequest('/api/quizzes', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${token}` },
      body: JSON.stringify({
        title: 'Teste de Bloqueio de Plano',
        description: 'Quiz para testar se plano expirado bloqueia cria√ß√£o'
      })
    });
    
    log(`üéØ Teste de cria√ß√£o de quiz: ${JSON.stringify(quizTest, null, 2)}`, 'blue');
    
    // Verificar se h√° sistema de renova√ß√£o
    const renewalOptions = await makeRequest('/api/subscription/renewal-options', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üîÑ Op√ß√µes de renova√ß√£o: ${JSON.stringify(renewalOptions, null, 2)}`, 'blue');
    
    return {
      success: true,
      userStatus,
      quizCreation: quizTest,
      renewalOptions
    };
    
  } catch (error) {
    log(`‚ùå Erro no teste de expira√ß√£o/renova√ß√£o: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

// Teste 6: Sincroniza√ß√£o Completa
async function testarSincronizacaoCompleta(token) {
  log('\nüîÑ TESTE 6: Sincroniza√ß√£o Completa dos Sistemas', 'cyan');
  
  try {
    // Buscar dados consolidados
    const dashboardData = await makeRequest('/api/dashboard/unified', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üìä Dados consolidados: ${JSON.stringify(dashboardData, null, 2)}`, 'blue');
    
    // Verificar se todos os sistemas est√£o sincronizados
    const systemHealth = await makeRequest('/api/system/health', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    log(`üè• Sa√∫de do sistema: ${JSON.stringify(systemHealth, null, 2)}`, 'blue');
    
    return {
      success: true,
      dashboard: dashboardData,
      health: systemHealth
    };
    
  } catch (error) {
    log(`‚ùå Erro na sincroniza√ß√£o completa: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

// Executar todos os testes
async function executarTodosOsTestes() {
  log('üöÄ INICIANDO TESTE COMPLETO DO SISTEMA DE CR√âDITOS', 'magenta');
  log('================================================', 'magenta');
  
  try {
    // Autenticar
    const token = await authenticate();
    
    // Executar todos os testes
    const resultados = {
      emailMarketing: await testarCreditosEmailMarketing(token),
      sms: await testarCreditosSMS(token),
      stripe: await testarIntegra√ß√£oStripe(token),
      planosQuiz: await testarPlanosQuiz(token),
      expiracaoRenovacao: await testarExpiracaoRenovacao(token),
      sincronizacao: await testarSincronizacaoCompleta(token)
    };
    
    // Gerar relat√≥rio final
    log('\nüìã RELAT√ìRIO FINAL', 'magenta');
    log('==================', 'magenta');
    
    let totalTestes = 0;
    let testesAprovados = 0;
    
    Object.keys(resultados).forEach(teste => {
      totalTestes++;
      if (resultados[teste].success) {
        testesAprovados++;
        log(`‚úÖ ${teste}: APROVADO`, 'green');
      } else {
        log(`‚ùå ${teste}: REPROVADO - ${resultados[teste].error}`, 'red');
      }
    });
    
    const taxaSucesso = Math.round((testesAprovados / totalTestes) * 100);
    
    log(`\nüìä TAXA DE SUCESSO: ${taxaSucesso}% (${testesAprovados}/${totalTestes} testes)`, 'cyan');
    
    if (taxaSucesso >= 80) {
      log('üéâ SISTEMA APROVADO PARA PRODU√á√ÉO!', 'green');
    } else {
      log('‚ö†Ô∏è  SISTEMA PRECISA DE CORRE√á√ïES', 'yellow');
    }
    
    return {
      taxaSucesso,
      testesAprovados,
      totalTestes,
      resultados
    };
    
  } catch (error) {
    log(`üí• ERRO CR√çTICO: ${error.message}`, 'red');
    return { taxaSucesso: 0, error: error.message };
  }
}

// Executar se chamado diretamente
if (import.meta.url === `file://${process.argv[1]}`) {
  executarTodosOsTestes().then(resultado => {
    console.log('\nüèÅ Teste conclu√≠do!');
    process.exit(resultado.taxaSucesso >= 80 ? 0 : 1);
  }).catch(error => {
    console.error('üí• Erro fatal:', error);
    process.exit(1);
  });
}

export default executarTodosOsTestes;