// SISTEMA DE NOTIFICA√á√ïES PWA - TESTE COMPLETO FINAL
// Este teste valida todo o sistema de notifica√ß√µes push implementado

import crypto from 'crypto';
import fs from 'fs';
import fetch from 'node-fetch';

// Definir fetch globalmente
global.fetch = fetch;

console.log('üîî TESTE SISTEMA NOTIFICA√á√ïES PWA - VENDZZ PLATAFORM');
console.log('====================================================');

class PWANotificationTester {
  constructor() {
    this.accessToken = null;
    this.baseUrl = 'http://localhost:5000';
    this.testResults = [];
  }

  // Helper para fazer requisi√ß√µes HTTP
  async makeRequest(method, endpoint, data = null, headers = {}) {
    const options = {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
    };

    if (data && method !== 'GET') {
      options.body = JSON.stringify(data);
    }

    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, options);
      const responseData = await response.json().catch(() => ({}));
      
      return {
        success: response.ok,
        status: response.status,
        data: responseData,
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Login e obten√ß√£o do token JWT
  async authenticate() {
    console.log('\nüìù FASE 1: Autentica√ß√£o JWT...');
    
    const loginResponse = await this.makeRequest('POST', '/api/auth/login', {
      email: 'admin@admin.com',
      password: 'admin123'
    });

    if (loginResponse.success && loginResponse.data.accessToken) {
      this.accessToken = loginResponse.data.accessToken;
      console.log('‚úÖ Login realizado com sucesso');
      return true;
    } else {
      console.log('‚ùå Falha no login:', loginResponse.data?.message || 'Erro desconhecido');
      return false;
    }
  }

  // Obter headers com autentica√ß√£o
  getAuthHeaders() {
    return {
      'Authorization': `Bearer ${this.accessToken}`,
    };
  }

  // Teste 1: Verificar endpoints de notifica√ß√µes
  async testNotificationEndpoints() {
    console.log('\nüîß FASE 2: Testando endpoints de notifica√ß√µes...');
    
    const tests = [
      {
        name: 'GET /api/notifications/vapid-key',
        method: 'GET',
        endpoint: '/api/notifications/vapid-key',
        expectSuccess: true,
        description: 'Obter chave VAPID p√∫blica'
      },
      {
        name: 'GET /api/notifications/stats',
        method: 'GET',
        endpoint: '/api/notifications/stats',
        requiresAuth: true,
        expectSuccess: true,
        description: 'Obter estat√≠sticas de notifica√ß√µes'
      },
      {
        name: 'POST /api/notifications/test',
        method: 'POST',
        endpoint: '/api/notifications/test',
        requiresAuth: true,
        expectSuccess: false, // Espera falhar pois usu√°rio n√£o est√° inscrito
        description: 'Enviar notifica√ß√£o de teste'
      }
    ];

    for (const test of tests) {
      const headers = test.requiresAuth ? this.getAuthHeaders() : {};
      const response = await this.makeRequest(test.method, test.endpoint, null, headers);
      
      const success = test.expectSuccess ? response.success : !response.success;
      
      console.log(`${success ? '‚úÖ' : '‚ùå'} ${test.name}: ${test.description}`);
      console.log(`   Status: ${response.status}, Sucesso: ${response.success}`);
      
      if (response.data && Object.keys(response.data).length > 0) {
        console.log(`   Dados:`, Object.keys(response.data).join(', '));
      }

      this.testResults.push({
        test: test.name,
        success,
        response: response
      });
    }
  }

  // Teste 2: Simular subscription de usu√°rio
  async testNotificationSubscription() {
    console.log('\nüì± FASE 3: Testando subscri√ß√£o de notifica√ß√µes...');

    // Simular dados de subscription do browser
    const mockSubscription = {
      endpoint: 'https://fcm.googleapis.com/fcm/send/test-endpoint',
      keys: {
        p256dh: crypto.randomBytes(65).toString('base64'),
        auth: crypto.randomBytes(16).toString('base64')
      }
    };

    const response = await this.makeRequest(
      'POST', 
      '/api/notifications/subscribe', 
      { subscription: mockSubscription },
      this.getAuthHeaders()
    );

    console.log(`${response.success ? '‚úÖ' : '‚ùå'} Subscription de usu√°rio`);
    console.log(`   Status: ${response.status}`);
    console.log(`   Mensagem: ${response.data?.message || 'N/A'}`);

    this.testResults.push({
      test: 'Notification Subscription',
      success: response.success,
      response: response
    });

    return response.success;
  }

  // Teste 3: Envio de notifica√ß√£o personalizada
  async testCustomNotification() {
    console.log('\nüì® FASE 4: Testando envio de notifica√ß√£o personalizada...');

    const notificationData = {
      title: 'üéØ Teste PWA Vendzz',
      body: 'Sistema de notifica√ß√µes funcionando perfeitamente!',
      icon: '/icon-192x192.png',
      url: '/pwa-dashboard',
      priority: 'high'
    };

    const response = await this.makeRequest(
      'POST',
      '/api/notifications/send',
      notificationData,
      this.getAuthHeaders()
    );

    console.log(`${response.success ? '‚úÖ' : '‚ùå'} Envio de notifica√ß√£o personalizada`);
    console.log(`   Status: ${response.status}`);
    console.log(`   Dados enviados:`, notificationData.title);

    this.testResults.push({
      test: 'Custom Notification Send',
      success: response.success,
      response: response
    });
  }

  // Teste 4: Envio de notifica√ß√£o em lote
  async testBulkNotification() {
    console.log('\nüì¢ FASE 5: Testando envio de notifica√ß√£o em lote...');

    const bulkData = {
      title: 'üìä Notifica√ß√£o em Lote',
      body: 'Teste de envio para m√∫ltiplos usu√°rios',
      icon: '/icon-192x192.png',
      userIds: ['admin-user-id', 'test-user-1', 'test-user-2']
    };

    const response = await this.makeRequest(
      'POST',
      '/api/notifications/send-bulk',
      bulkData,
      this.getAuthHeaders()
    );

    console.log(`${response.success ? '‚úÖ' : '‚ùå'} Envio de notifica√ß√£o em lote`);
    console.log(`   Status: ${response.status}`);
    console.log(`   Usu√°rios alvo: ${bulkData.userIds.length}`);

    this.testResults.push({
      test: 'Bulk Notification Send',
      success: response.success,
      response: response
    });
  }

  // Teste 5: Validar estat√≠sticas do sistema
  async testNotificationStats() {
    console.log('\nüìà FASE 6: Validando estat√≠sticas do sistema...');

    const response = await this.makeRequest(
      'GET',
      '/api/notifications/stats',
      null,
      this.getAuthHeaders()
    );

    if (response.success && response.data) {
      console.log('‚úÖ Estat√≠sticas obtidas com sucesso');
      console.log(`   VAPID Key presente: ${response.data.vapidPublicKey ? 'Sim' : 'N√£o'}`);
      console.log(`   Total Subscriptions: ${response.data.totalSubscriptions || 0}`);
      console.log(`   Active Subscriptions: ${response.data.activeSubscriptions || 0}`);
    } else {
      console.log('‚ùå Erro ao obter estat√≠sticas');
    }

    this.testResults.push({
      test: 'Notification Statistics',
      success: response.success,
      response: response
    });
  }

  // Teste 6: Sistema de PWA - Verifica√ß√µes frontend
  async testPWAIntegration() {
    console.log('\nüîß FASE 7: Validando integra√ß√£o PWA...');

    // Verificar se arquivos PWA existem
    const pwaFiles = [
      'public/manifest.json',
      'public/sw.js',
      'public/icon-192x192.png',
      'client/src/pages/app-pwa-complete.tsx'
    ];

    let pwaFilesValid = 0;

    for (const file of pwaFiles) {
      if (fs.existsSync(file)) {
        console.log(`‚úÖ Arquivo PWA encontrado: ${file}`);
        pwaFilesValid++;
      } else {
        console.log(`‚ùå Arquivo PWA ausente: ${file}`);
      }
    }

    const pwaIntegrationSuccess = pwaFilesValid === pwaFiles.length;
    
    console.log(`\nüì± Integra√ß√£o PWA: ${pwaIntegrationSuccess ? '‚úÖ COMPLETA' : '‚ùå INCOMPLETA'}`);
    console.log(`   Arquivos v√°lidos: ${pwaFilesValid}/${pwaFiles.length}`);

    this.testResults.push({
      test: 'PWA Integration',
      success: pwaIntegrationSuccess,
      details: { validFiles: pwaFilesValid, totalFiles: pwaFiles.length }
    });
  }

  // Gerar relat√≥rio final
  generateReport() {
    console.log('\nüìä RELAT√ìRIO FINAL DO SISTEMA DE NOTIFICA√á√ïES PWA');
    console.log('==================================================');

    const totalTests = this.testResults.length;
    const successfulTests = this.testResults.filter(t => t.success).length;
    const successRate = ((successfulTests / totalTests) * 100).toFixed(1);

    console.log(`\nüìà RESULTADO GERAL:`);
    console.log(`   Total de testes: ${totalTests}`);
    console.log(`   Testes aprovados: ${successfulTests}`);
    console.log(`   Taxa de sucesso: ${successRate}%`);

    console.log(`\nüìã DETALHAMENTO POR TESTE:`);
    this.testResults.forEach((result, index) => {
      const status = result.success ? '‚úÖ PASSOU' : '‚ùå FALHOU';
      console.log(`   ${index + 1}. ${result.test}: ${status}`);
    });

    // Diagn√≥stico do sistema
    console.log(`\nüîç DIAGN√ìSTICO DO SISTEMA:`);
    
    if (successRate >= 85) {
      console.log('‚úÖ SISTEMA APROVADO PARA PRODU√á√ÉO');
      console.log('   - Backend de notifica√ß√µes implementado');
      console.log('   - Endpoints funcionando corretamente'); 
      console.log('   - Integra√ß√£o PWA completa');
      console.log('   - Sistema pronto para usu√°rios reais');
    } else if (successRate >= 70) {
      console.log('‚ö†Ô∏è SISTEMA FUNCIONAL COM MELHORIAS');
      console.log('   - Funcionalidades principais implementadas');
      console.log('   - Algumas otimiza√ß√µes necess√°rias');
      console.log('   - Aprovado para testes com usu√°rios');
    } else {
      console.log('‚ùå SISTEMA REQUER CORRE√á√ïES');
      console.log('   - Problemas cr√≠ticos identificados');
      console.log('   - Revis√£o de implementa√ß√£o necess√°ria');
    }

    // Salvar relat√≥rio
    const reportData = {
      timestamp: new Date().toISOString(),
      totalTests,
      successfulTests,
      successRate: `${successRate}%`,
      results: this.testResults,
      status: successRate >= 85 ? 'APPROVED' : successRate >= 70 ? 'FUNCTIONAL' : 'NEEDS_FIXES'
    };

    fs.writeFileSync(
      `RELATORIO-NOTIFICACOES-PWA-${Date.now()}.json`,
      JSON.stringify(reportData, null, 2)
    );

    console.log(`\nüíæ Relat√≥rio detalhado salvo: RELATORIO-NOTIFICACOES-PWA-${Date.now()}.json`);

    return {
      successRate: parseFloat(successRate),
      status: reportData.status,
      totalTests,
      successfulTests
    };
  }

  // Executar todos os testes
  async runAllTests() {
    console.log('üöÄ Iniciando teste completo do sistema de notifica√ß√µes PWA...\n');

    try {
      // Fase 1: Autentica√ß√£o
      const authSuccess = await this.authenticate();
      if (!authSuccess) {
        throw new Error('Falha na autentica√ß√£o inicial');
      }

      // Fase 2: Teste de endpoints
      await this.testNotificationEndpoints();

      // Fase 3: Subscription test
      await this.testNotificationSubscription();

      // Fase 4: Custom notification
      await this.testCustomNotification();

      // Fase 5: Bulk notification
      await this.testBulkNotification();

      // Fase 6: Statistics
      await this.testNotificationStats();

      // Fase 7: PWA Integration
      await this.testPWAIntegration();

      // Gerar relat√≥rio
      const report = this.generateReport();
      
      return report;

    } catch (error) {
      console.log(`\n‚ùå ERRO CR√çTICO NO TESTE: ${error.message}`);
      return {
        successRate: 0,
        status: 'CRITICAL_ERROR',
        error: error.message
      };
    }
  }
}

// Executar testes diretamente
const tester = new PWANotificationTester();

tester.runAllTests().then(result => {
  process.exit(result.successRate >= 70 ? 0 : 1);
}).catch(error => {
  console.error('Erro fatal:', error);
  process.exit(1);
});

export default PWANotificationTester;