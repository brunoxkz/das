/**
 * TESTE DE RECUPERA√á√ÉO DE FALHAS
 * Simula falhas espec√≠ficas e testa recupera√ß√£o do sistema
 */

const BASE_URL = 'http://localhost:5000';
const ADMIN_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjFFYVk2dkUwcllBa1RYdjV2SENsbSIsImVtYWlsIjoiYWRtaW5AdmVuZHp6LmNvbSIsInBsYW4iOiJlbnRlcnByaXNlIiwicm9sZSI6ImFkbWluIiwidHlwZSI6ImFjY2VzcyIsImlhdCI6MTc1MjM0MTUyOCwiZXhwIjoxNzUyNDI3OTI4fQ.yG862OoMegQ1D9qIdCb2-oZziUo7XS_SBPbLd7vDRng';

const recoveryResults = {
  totalTests: 0,
  passedTests: 0,
  failedTests: 0,
  recoveryTimes: [],
  failureScenarios: []
};

async function makeRequest(url, options = {}) {
  const start = Date.now();
  
  try {
    const response = await fetch(`${BASE_URL}${url}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${ADMIN_TOKEN}`,
        ...options.headers
      }
    });
    
    const duration = Date.now() - start;
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorText.substring(0, 100)}`);
    }
    
    const data = await response.json();
    return { success: true, data, duration, status: response.status };
    
  } catch (error) {
    const duration = Date.now() - start;
    return { success: false, error: error.message, duration };
  }
}

function logRecoveryTest(testName, result, recoveryTime = null) {
  recoveryResults.totalTests++;
  
  if (result.success) {
    recoveryResults.passedTests++;
    console.log(`‚úÖ ${testName} - PASSOU (${result.duration}ms)`);
    if (recoveryTime) {
      console.log(`   üîÑ Tempo de recupera√ß√£o: ${recoveryTime}ms`);
      recoveryResults.recoveryTimes.push(recoveryTime);
    }
  } else {
    recoveryResults.failedTests++;
    console.log(`‚ùå ${testName} - FALHOU (${result.duration}ms)`);
    console.log(`   Erro: ${result.error}`);
    
    recoveryResults.failureScenarios.push({
      test: testName,
      error: result.error,
      duration: result.duration
    });
  }
}

// TESTE 1: Recupera√ß√£o de Token Expirado
async function testTokenRecovery() {
  console.log('\nüîë TESTE 1: Recupera√ß√£o de Token Expirado');
  
  // Simular token expirado
  const invalidTokenResult = await makeRequest('/api/dashboard/stats', {
    headers: {
      'Authorization': 'Bearer token-expirado-123'
    }
  });
  
  logRecoveryTest('Token Expirado (Deve Falhar)', { success: !invalidTokenResult.success, duration: invalidTokenResult.duration });
  
  // Verificar se sistema volta ao normal com token v√°lido
  const recoveryStart = Date.now();
  const validTokenResult = await makeRequest('/api/dashboard/stats');
  const recoveryTime = Date.now() - recoveryStart;
  
  logRecoveryTest('Recupera√ß√£o com Token V√°lido', validTokenResult, recoveryTime);
}

// TESTE 2: Recupera√ß√£o de Sobrecarga
async function testOverloadRecovery() {
  console.log('\n‚ö° TESTE 2: Recupera√ß√£o de Sobrecarga');
  
  // Simular sobrecarga com muitas requisi√ß√µes
  const overloadStart = Date.now();
  const overloadRequests = Array.from({ length: 50 }, (_, i) => 
    makeRequest(`/api/dashboard/stats?overload=${i}`)
  );
  
  const overloadResults = await Promise.allSettled(overloadRequests);
  const overloadTime = Date.now() - overloadStart;
  
  const successful = overloadResults.filter(r => r.status === 'fulfilled' && r.value.success).length;
  const overloadResult = { success: successful >= 40, duration: overloadTime };
  
  logRecoveryTest('Resist√™ncia √† Sobrecarga', overloadResult);
  
  // Aguardar sistema se recuperar
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Verificar se sistema volta ao normal
  const recoveryStart = Date.now();
  const normalResult = await makeRequest('/api/dashboard/stats');
  const recoveryTime = Date.now() - recoveryStart;
  
  logRecoveryTest('Recupera√ß√£o P√≥s-Sobrecarga', normalResult, recoveryTime);
}

// TESTE 3: Recupera√ß√£o de Dados Corrompidos
async function testCorruptedDataRecovery() {
  console.log('\nüíæ TESTE 3: Recupera√ß√£o de Dados Corrompidos');
  
  // Tentar enviar dados corrompidos
  const corruptedData = {
    title: null,
    structure: "dados-corrompidos",
    invalid: { corrupt: true, data: undefined }
  };
  
  const corruptedResult = await makeRequest('/api/quizzes', {
    method: 'POST',
    body: JSON.stringify(corruptedData)
  });
  
  logRecoveryTest('Dados Corrompidos (Deve Falhar)', { success: !corruptedResult.success, duration: corruptedResult.duration });
  
  // Verificar se sistema aceita dados v√°lidos ap√≥s corrup√ß√£o
  const recoveryStart = Date.now();
  const validData = {
    title: 'Quiz V√°lido Ap√≥s Corrup√ß√£o',
    description: 'Teste de recupera√ß√£o',
    structure: {
      pages: [{
        id: 'page1',
        name: 'P√°gina 1',
        elements: [{
          id: 'text1',
          type: 'text',
          question: 'Teste?',
          fieldId: 'teste'
        }]
      }]
    }
  };
  
  const validResult = await makeRequest('/api/quizzes', {
    method: 'POST',
    body: JSON.stringify(validData)
  });
  
  const recoveryTime = Date.now() - recoveryStart;
  logRecoveryTest('Recupera√ß√£o com Dados V√°lidos', validResult, recoveryTime);
  
  // Cleanup
  if (validResult.success) {
    await makeRequest(`/api/quizzes/${validResult.data.id}`, { method: 'DELETE' });
  }
}

// TESTE 4: Recupera√ß√£o de Conex√£o de Banco
async function testDatabaseRecovery() {
  console.log('\nüóÑÔ∏è TESTE 4: Recupera√ß√£o de Conex√£o de Banco');
  
  // Fazer v√°rias opera√ß√µes que dependem do banco
  const dbOperations = [
    () => makeRequest('/api/quizzes'),
    () => makeRequest('/api/dashboard/stats'),
    () => makeRequest('/api/user/credits'),
    () => makeRequest('/api/analytics/recent-activity')
  ];
  
  const recoveryStart = Date.now();
  const dbResults = await Promise.allSettled(dbOperations.map(op => op()));
  const recoveryTime = Date.now() - recoveryStart;
  
  const successful = dbResults.filter(r => r.status === 'fulfilled' && r.value.success).length;
  const dbRecoveryResult = { success: successful >= 3, duration: recoveryTime };
  
  logRecoveryTest('Opera√ß√µes de Banco', dbRecoveryResult, recoveryTime);
}

// TESTE 5: Recupera√ß√£o de Mem√≥ria
async function testMemoryRecovery() {
  console.log('\nüß† TESTE 5: Recupera√ß√£o de Mem√≥ria');
  
  // Simular opera√ß√µes que consomem mem√≥ria
  const memoryIntensiveOperations = Array.from({ length: 20 }, (_, i) => 
    makeRequest(`/api/dashboard/stats?memory=${i}&data=${'x'.repeat(1000)}`)
  );
  
  const memoryStart = Date.now();
  const memoryResults = await Promise.allSettled(memoryIntensiveOperations);
  const memoryTime = Date.now() - memoryStart;
  
  const successful = memoryResults.filter(r => r.status === 'fulfilled' && r.value.success).length;
  const memoryResult = { success: successful >= 15, duration: memoryTime };
  
  logRecoveryTest('Opera√ß√µes Intensivas de Mem√≥ria', memoryResult);
  
  // Aguardar garbage collection
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Verificar se sistema volta ao normal
  const recoveryStart = Date.now();
  const normalResult = await makeRequest('/api/dashboard/stats');
  const recoveryTime = Date.now() - recoveryStart;
  
  logRecoveryTest('Recupera√ß√£o P√≥s-Mem√≥ria', normalResult, recoveryTime);
}

// TESTE 6: Recupera√ß√£o de Timeout
async function testTimeoutRecovery() {
  console.log('\n‚è±Ô∏è TESTE 6: Recupera√ß√£o de Timeout');
  
  // Simular opera√ß√£o que pode dar timeout
  const timeoutController = new AbortController();
  setTimeout(() => timeoutController.abort(), 1000); // 1 segundo timeout
  
  const timeoutResult = await makeRequest('/api/dashboard/stats', {
    signal: timeoutController.signal
  }).catch(error => ({ success: false, error: error.message, duration: 1000 }));
  
  logRecoveryTest('Opera√ß√£o com Timeout', timeoutResult);
  
  // Verificar se sistema responde normalmente ap√≥s timeout
  const recoveryStart = Date.now();
  const normalResult = await makeRequest('/api/dashboard/stats');
  const recoveryTime = Date.now() - recoveryStart;
  
  logRecoveryTest('Recupera√ß√£o P√≥s-Timeout', normalResult, recoveryTime);
}

// TESTE 7: Recupera√ß√£o de Concorr√™ncia
async function testConcurrencyRecovery() {
  console.log('\nüîÑ TESTE 7: Recupera√ß√£o de Concorr√™ncia');
  
  // Simular opera√ß√µes concorrentes conflitantes
  const concurrentOperations = [
    () => makeRequest('/api/dashboard/stats'),
    () => makeRequest('/api/quizzes'),
    () => makeRequest('/api/user/credits'),
    () => makeRequest('/api/analytics/recent-activity'),
    () => makeRequest('/api/dashboard/stats'),
    () => makeRequest('/api/quizzes'),
    () => makeRequest('/api/user/credits'),
    () => makeRequest('/api/analytics/recent-activity')
  ];
  
  const concurrencyStart = Date.now();
  const concurrentResults = await Promise.all(concurrentOperations.map(op => op()));
  const concurrencyTime = Date.now() - concurrencyStart;
  
  const successful = concurrentResults.filter(r => r.success).length;
  const concurrencyResult = { success: successful >= 6, duration: concurrencyTime };
  
  logRecoveryTest('Opera√ß√µes Concorrentes', concurrencyResult, concurrencyTime);
}

// Fun√ß√£o principal
async function runRecoveryTests() {
  console.log('üõ°Ô∏è TESTE DE RECUPERA√á√ÉO DE FALHAS');
  console.log('üîß Testando capacidade de recupera√ß√£o do sistema');
  console.log('=' .repeat(60));
  
  const startTime = Date.now();
  
  try {
    // Executar todos os testes de recupera√ß√£o
    await testTokenRecovery();
    await testOverloadRecovery();
    await testCorruptedDataRecovery();
    await testDatabaseRecovery();
    await testMemoryRecovery();
    await testTimeoutRecovery();
    await testConcurrencyRecovery();
    
    // Calcular estat√≠sticas finais
    const totalDuration = Date.now() - startTime;
    const successRate = (recoveryResults.passedTests / recoveryResults.totalTests * 100).toFixed(1);
    const avgRecoveryTime = recoveryResults.recoveryTimes.length > 0 
      ? Math.round(recoveryResults.recoveryTimes.reduce((a, b) => a + b, 0) / recoveryResults.recoveryTimes.length)
      : 0;
    
    console.log('\n' + '=' .repeat(60));
    console.log('üìä RELAT√ìRIO DE RECUPERA√á√ÉO DE FALHAS');
    console.log('=' .repeat(60));
    
    console.log(`üìà RESUMO:`);
    console.log(`   Total de Testes: ${recoveryResults.totalTests}`);
    console.log(`   Testes Passaram: ${recoveryResults.passedTests}`);
    console.log(`   Testes Falharam: ${recoveryResults.failedTests}`);
    console.log(`   Taxa de Sucesso: ${successRate}%`);
    console.log(`   Tempo Total: ${Math.round(totalDuration / 1000)}s`);
    console.log(`   Tempo M√©dio de Recupera√ß√£o: ${avgRecoveryTime}ms`);
    
    // An√°lise de recupera√ß√£o
    if (recoveryResults.recoveryTimes.length > 0) {
      const fastestRecovery = Math.min(...recoveryResults.recoveryTimes);
      const slowestRecovery = Math.max(...recoveryResults.recoveryTimes);
      
      console.log(`\n‚ö° TEMPOS DE RECUPERA√á√ÉO:`);
      console.log(`   Mais R√°pida: ${fastestRecovery}ms`);
      console.log(`   Mais Lenta: ${slowestRecovery}ms`);
      console.log(`   M√©dia: ${avgRecoveryTime}ms`);
    }
    
    // Cen√°rios de falha
    if (recoveryResults.failureScenarios.length > 0) {
      console.log(`\nüö® CEN√ÅRIOS DE FALHA:`);
      recoveryResults.failureScenarios.forEach((scenario, index) => {
        console.log(`   ${index + 1}. ${scenario.test}: ${scenario.error}`);
      });
    }
    
    // Avalia√ß√£o de resili√™ncia
    console.log(`\nüõ°Ô∏è AVALIA√á√ÉO DE RESILI√äNCIA:`);
    if (parseFloat(successRate) >= 90) {
      console.log(`   üèÜ EXCELENTE: Sistema altamente resiliente!`);
    } else if (parseFloat(successRate) >= 75) {
      console.log(`   ‚úÖ BOM: Sistema resiliente com pequenos pontos de melhoria`);
    } else if (parseFloat(successRate) >= 50) {
      console.log(`   ‚ö†Ô∏è  M√âDIO: Sistema precisa de melhorias na recupera√ß√£o`);
    } else {
      console.log(`   üö® CR√çTICO: Sistema n√£o √© resiliente a falhas`);
    }
    
    if (avgRecoveryTime <= 200) {
      console.log(`   üöÄ Recupera√ß√£o ultra-r√°pida detectada`);
    } else if (avgRecoveryTime <= 500) {
      console.log(`   ‚ö° Recupera√ß√£o r√°pida na maioria dos casos`);
    } else {
      console.log(`   üêå Recupera√ß√£o lenta detectada`);
    }
    
    // Recomenda√ß√µes
    console.log(`\nüí° RECOMENDA√á√ïES:`);
    if (recoveryResults.failedTests === 0) {
      console.log(`   üéØ Sistema passou em todos os testes de recupera√ß√£o!`);
    } else {
      console.log(`   üîß Focar na melhoria dos cen√°rios que falharam`);
    }
    
    if (avgRecoveryTime > 300) {
      console.log(`   ‚ö° Otimizar tempos de recupera√ß√£o`);
    }
    
    console.log(`   üìä Implementar monitoramento de resili√™ncia em produ√ß√£o`);
    
  } catch (error) {
    console.error('üö® ERRO CR√çTICO NOS TESTES DE RECUPERA√á√ÉO:', error);
  }
}

// Executar teste
runRecoveryTests().catch(console.error);